# 白名单功能设计文档

## 功能概述
白名单功能用于限制只有特定MAC地址的设备才能访问服务器。系统将验证连接设备的MAC地址是否在白名单中，只有通过验证的设备才能建立有效连接。

## 存储方案比较
针对白名单存储方案，我们有两种主要选择：文本文件存储和SQLite数据库存储。下面对这两种方案进行详细比较：

### 1. 文本文件存储方案

**优点：**
- 实现简单，无需额外的数据库操作
- 配置直观，便于手动编辑和查看
- 适合小规模部署或简单场景
- 无需数据库依赖

**缺点：**
- 不支持复杂查询和条件过滤
- 并发读写可能导致文件损坏
- 不便于动态管理（增删改查操作繁琐）
- 无法存储额外信息（如备注、有效期等）
- 大规模白名单性能较差

**实现方式：**
- 创建`whitelist.txt`文件，每行存储一个MAC地址
- 服务启动时加载全部MAC地址到内存
- 提供简单的文件读取接口进行验证

### 2. SQLite数据库存储方案

**优点：**
- 与项目现有技术栈兼容（已使用SQLite）
- 支持复杂查询和条件过滤
- 并发访问更安全可靠
- 便于动态管理和维护
- 可以存储额外信息（如设备名称、备注、添加时间等）
- 扩展性更好，方便未来增加功能
- 性能更稳定，适合大规模白名单

**缺点：**
- 实现稍复杂，需要创建模型和数据库操作接口
- 依赖数据库，增加了一定的复杂度
- 不便于直接编辑配置（需要数据库工具或管理界面）

## 推荐方案
基于项目现状和长远考虑，**推荐使用SQLite数据库存储白名单**。理由如下：

1. **技术栈兼容性**：项目已经集成了SQLite数据库和GORM ORM框架，可以直接复用现有组件
2. **扩展性**：数据库方案更容易扩展，可以方便地增加设备信息、有效期等额外字段
3. **维护性**：使用数据库可以更方便地实现白名单的增删改查操作，便于后期维护
4. **与认证系统集成**：更容易与项目现有的认证系统集成，统一管理认证和授权
5. **性能考虑**：对于中大规模白名单，数据库的查询性能更优

## 实现方案

### 1. 数据库设计
创建`DeviceWhitelist`表，结构如下：
```go
// DeviceWhitelist 设备白名单模型
type DeviceWhitelist struct {
    ID          uint      `gorm:"primaryKey" json:"id"`
    MacAddress  string    `gorm:"type:varchar(255);uniqueIndex;not null" json:"mac_address"` // MAC地址，唯一索引
    DeviceName  string    `gorm:"type:varchar(255)" json:"device_name"`                      // 设备名称（可选）
    Description string    `gorm:"type:text" json:"description"`                             // 设备描述（可选）
    Enabled     bool      `gorm:"default:true" json:"enabled"`                             // 是否启用
    CreatedAt   time.Time `json:"created_at"`                                                // 创建时间
    UpdatedAt   time.Time `json:"updated_at"`                                                // 更新时间
}
```

### 2. 接口设计
创建白名单管理接口，提供以下功能：
- 添加MAC地址到白名单
- 从白名单中删除MAC地址
- 查询MAC地址是否在白名单中
- 获取白名单列表
- 更新白名单中的设备信息

### 3. 集成方案
与现有认证系统集成，在设备连接验证过程中增加白名单检查步骤：
1. 设备连接时，获取其MAC地址
2. 检查MAC地址是否在白名单中
3. 如果启用了认证，继续进行现有认证流程
4. 如果未启用认证但启用了白名单，则只验证MAC地址

### 4. 配置项
在`config.yaml`中添加白名单相关配置：
```yaml
# 白名单配置
whitelist:
  # 是否启用白名单功能
  enabled: false
  # 白名单模式：whitelist(仅允许白名单内设备) / blacklist(禁止黑名单内设备)
  mode: whitelist
  # 当白名单验证失败时的处理方式：reject(拒绝连接) / alert(记录警告但允许连接)
  action: reject
  # 白名单存储方式：file(文件) / database(数据库)
  storage: database
  # 文件存储路径（仅当storage为file时有效）
  file_path: "config/whitelist.txt"
```

## 具体实现步骤

1. **创建数据库模型**：在`src/models`目录下创建`whitelist.go`文件，定义`DeviceWhitelist`结构体
2. **创建存储接口**：在`src/core/whitelist`目录下创建接口和实现
3. **创建白名单管理器**：实现白名单的增删改查功能
4. **集成到连接处理**：在连接建立过程中增加白名单验证逻辑
5. **添加配置项**：在配置文件和配置解析中添加白名单相关配置
6. **提供API接口**：（可选）提供REST API接口用于管理白名单

## 安全性考虑

1. 对MAC地址格式进行严格验证，防止无效数据
2. 实现适当的并发控制，避免数据库操作冲突
3. 定期备份白名单数据，防止数据丢失
4. （可选）添加审计日志，记录白名单的修改历史
5. （可选）对敏感操作添加权限控制

## 总结

SQLite数据库存储方案虽然在初期实现上略复杂，但从项目长远发展和维护角度考虑，具有明显优势。特别是与项目现有技术栈的兼容性、扩展性以及与认证系统的集成方面，数据库方案都更加合适。建议按照上述设计方案实施白名单功能，确保系统安全和稳定运行。